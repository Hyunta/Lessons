# 2장

## 2.1 호출 스택, 이벤트 루프

![image-20211001212705762](C:\Users\mohai\AppData\Roaming\Typora\typora-user-images\image-20211001212705762.png)



## 2.2 ES2015+ 문법

### 1. const, let 

- 15 이전에는 var로 변수를 선언
- var는 블록스코프를 무시한다, 바깥에서 접근가능 / function으로 감쌌을 때 밖에서 접근 불가능
- const는 블록스코프 밖에서 접근할 수 없다, =은 한번만 적용.
- let은 변경 가능하다.



### 2. 템플릿 문자열

```javascript
var won = 1000;
var result = '이 과자는 ' + won + '원입니다.';

const result = `이 과자는 ${won}입니다.`
```



### 3. 객체 리터럴

- 문자 표현이 더 간결해짐

![image-20211001215921984](C:\Users\mohai\AppData\Roaming\Typora\typora-user-images\image-20211001215921984.png)



### 4. 화살표 함수

function()을 대체할 수는 없음 (this 가 부모를 물려받지 못함)

this를 쓰는 경우 function을 사용



### 5. 구조분해 할당

this를 사용하고 있을 때 구조분해 할당 안하는게 좋다



### 6. 클래스

프로토타입 문법을 깔끔하게 작성할 수 있는 문법

Constructor 와 Extends를 깔끔하게 처리할 수 있음.



### 7. 프로미스

내용이 실행은 되었지만 결과를 아직 반환하지 않은 객체

Then을 붙이면 결과를 반환함

CallBack에서 Promise로 전환되는 중

Promise.all(배열) : 여러 개의 프로미스를 동시에 실행

- 하나라도 실패하면 catch로 감
- allSettled로 실패한 것만 추려낼 수 있음



### 8. async / await

await이 then 역할을 한다.

await을 사용할 대는 async가 붙어야 한다.

```javascript
const promise = new Promise(...)
promise.the((result) => ...)

async function main() {
  try{
    const result = await promise;
    return 'zerocho';
  } catch (error) {
      console.log(error);
  }
}

main().then((name) => ...)
or
const name = await main()
```

